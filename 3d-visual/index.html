<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Horizon Scanning Radar - Active Scan Mode</title>
    <style>
        /* --- BRIGHT THEME CSS --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f8fafc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #1e293b;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #e2e8f0 100%); 
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 25px;
            left: 25px;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: #0f172a;
        }

        p {
            margin: 6px 0 0 0;
            font-size: 14px;
            color: #475569;
            max-width: 400px;
            line-height: 1.4;
        }

        /* Legend */
        .legend {
            margin-top: 25px;
            background: rgba(255, 255, 255, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(203, 213, 225, 0.6);
            backdrop-filter: blur(12px);
            width: 340px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        .legend-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #10b981; 
            margin-bottom: 15px;
            font-weight: 800;
        }

        .legend-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.4;
            color: #334155;
        }

        .icon-box {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 24px;
            margin-right: 12px;
            flex-shrink: 0;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            display: none;
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid rgba(203, 213, 225, 0.8);
            color: #1e293b;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transform: translate(-50%, -120%);
            z-index: 100;
            transition: opacity 0.2s;
            width: 280px;
            backdrop-filter: blur(8px);
        }

        .tooltip-title {
            font-weight: 700;
            font-size: 16px;
            margin-bottom: 6px;
            border-bottom: 2px solid #f1f5f9;
            padding-bottom: 8px;
            color: #0f172a;
        }

        .tooltip-desc {
            font-size: 13px;
            margin-bottom: 12px;
            color: #64748b;
            line-height: 1.4;
        }

        .tooltip-data {
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px dashed #e2e8f0;
            color: #64748b;
        }
        
        .tooltip-data strong {
            color: #0f172a;
            font-family: monospace;
            font-weight: 700;
        }

        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: 800;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Settings Panel */
        #settings-panel {
            background: rgba(255, 255, 255, 0.85) !important;
            border: 1px solid rgba(203, 213, 225, 0.6) !important;
            color: #1e293b !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05) !important;
        }
        #settings-title { color: #10b981 !important; border-bottom-color: #f1f5f9 !important; }
        .settings-label { color: #334155 !important; }
        #nodeSizeValue { color: #10b981 !important; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Strategic Foresight Radar</h1>
        <p>3D Visualize your signals.</p>
        
        <div class="legend" style="pointer-events: auto;">
            <div class="legend-title">Radar Guide:</div>
            
            <div class="legend-item">
                <div class="icon-box">
                   <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2"><path d="M12 3l4 4-4 4M12 3v18M12 21l-4-4 4 4M3 12l4-4-4 4M3 12h18M21 12l-4-4 4 4"/></svg>
                </div>
                <div>
                <strong>Floor Position (X & Y):</strong>
                <br><span style="color:#64748b; font-size: 12px;">Location based on X-Axis and Y-Axis.</span>
            </div>
            </div>

            <div class="legend-item">
                <div class="icon-box">
                     <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2"><path d="M12 20V4M5 11l7-7 7 7"/></svg>
                </div>
                <div>
                    <strong>Altitude (Height):</strong> Z Axis / Urgency.
                    <br><span style="color:#64748b; font-size: 12px;">Higher = More URGENCY (Data Z).</span>
                </div>
            </div>
            
            <div class="legend-item">
                <div class="icon-box">
                    <div style="width: 22px; height: 22px; border-radius: 50%; background: linear-gradient(135deg, #10b981, #059669); box-shadow: 0 2px 5px rgba(0,0,0,0.1);"></div>
                </div>
                <div>
                    <strong>Sphere Size:</strong> Impact Magnitude.
                    <br><span style="color:#64748b; font-size: 12px;">Based on absolute value of Impact (Y).</span>
                </div>
            </div>
        </div>
    </div>

    <div id="settings-panel" style="position: absolute; top: 25px; right: 25px; padding: 20px; border-radius: 12px; backdrop-filter: blur(12px); width: 220px;">
        <div id="settings-title" style="font-size: 12px; font-weight: 800; text-transform: uppercase; margin-bottom: 15px; border-bottom: 1px solid; padding-bottom: 8px; letter-spacing: 1px;">
            Radar Controls
        </div>
        
        <div class="settings-label" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-size: 13px;">
            <label for="autoRotateToggle" style="cursor: pointer;">Auto-Rotate</label>
            <input type="checkbox" id="autoRotateToggle" checked style="cursor: pointer; accent-color: #10b981;">
        </div>

        <div class="settings-label" style="font-size: 13px; margin-bottom: 8px; display: flex; justify-content: space-between;">
            <span>Node Scale</span>
            <span id="nodeSizeValue" style="font-weight: bold; font-family: monospace;">100%</span>
        </div>
        <input type="range" id="nodeSizeSlider" min="0.2" max="2.0" step="0.1" value="1.0" style="width: 100%; cursor: pointer; accent-color: #10b981;">
    </div>

   <div id="tooltip">
    <div class="tooltip-title" id="tt-name">Signal Name</div>
    <div class="tooltip-desc" id="tt-desc">Description</div>
    <div style="margin-bottom: 12px;">
        <span id="tt-badge" class="status-badge">STATUS</span>
    </div>
        <div class="tooltip-data"><span>Sumbu X:</span> <strong id="tt-x"></strong></div>
        <div class="tooltip-data"><span>Sumbu Y:</span> <strong id="tt-y"></strong></div>
        <div class="tooltip-data"><span>Sumbu Z (Urgency):</span> <strong id="tt-z"></strong></div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // --- 1. SETUP (BRIGHT MODE) ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 70, 80); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ReinhardToneMapping; 
        renderer.toneMappingExposure = 1.1; 

        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 180;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xe2e8f0, 0.5);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(50, 80, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096; 
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.camera.left = -60;
        dirLight.shadow.camera.right = 60;
        dirLight.shadow.camera.top = 60;
        dirLight.shadow.camera.bottom = -60;
        dirLight.shadow.bias = -0.0005; 
        scene.add(dirLight);

        // --- 3. RADAR FLOOR & GLOWING GRID ---
        const numRings = 5;
        const maxRadius = 55;
        const neonGreen = 0x10b981; 
        
        const floorGeo = new THREE.PlaneGeometry(maxRadius * 2.8, maxRadius * 2.8);
        const floorMat = new THREE.ShadowMaterial({ opacity: 0.1 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0.05;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid Rings
        for (let i = 1; i <= numRings; i++) {
            const radius = (maxRadius / numRings) * i;
            const ringGeo = new THREE.RingGeometry(radius - 0.15, radius + 0.15, 128);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: neonGreen,     
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8, // Opacity ditebalkan karena tanpa additive blending
                depthWrite: false     
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
        }

        // Crosshair
        const crossMat = new THREE.LineBasicMaterial({ 
            color: neonGreen, 
            transparent: true, 
            opacity: 0.8, // Opacity ditebalkan
            linewidth: 2
        });
        const crossGeo1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-maxRadius * 1.2, 0, 0), new THREE.Vector3(maxRadius * 1.2, 0, 0)]);
        const crossGeo2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, -maxRadius * 1.2), new THREE.Vector3(0, 0, maxRadius * 1.2)]);
        scene.add(new THREE.Line(crossGeo1, crossMat));
        scene.add(new THREE.Line(crossGeo2, crossMat));

        // --- 3.5 RADAR SWEEP SCANNER ---
        const radarVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const radarFragmentShader = `
            uniform float uTime;
            uniform vec3 uColor;
            varying vec2 vUv;

            #define PI 3.14159265359

            void main() {
                vec2 center = vec2(0.5, 0.5);
                vec2 toCenter = vUv - center;
                float dist = length(toCenter);

                if (dist > 0.49 || dist < 0.01) discard;

                float angle = atan(toCenter.y, toCenter.x);
                float normalizedAngle = (angle + PI) / (2.0 * PI);
                float rotation = mod(-uTime * 0.3, 1.0);
                float diff = rotation - normalizedAngle;
                if (diff < 0.0) diff += 1.0;

                float alpha = smoothstep(0.0, 0.35, diff); 
                alpha = 1.0 - alpha;
                alpha = pow(alpha, 3.0);

                gl_FragColor = vec4(uColor, alpha * 0.4); 
            }
        `;

        const sweepGeo = new THREE.PlaneGeometry(maxRadius * 2.1, maxRadius * 2.1);
        window.sweepMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(neonGreen) } 
            },
            vertexShader: radarVertexShader,
            fragmentShader: radarFragmentShader,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        const sweepMesh = new THREE.Mesh(sweepGeo, window.sweepMat);
        sweepMesh.rotation.x = -Math.PI / 2;
        sweepMesh.position.y = 0.02; 
        scene.add(sweepMesh);

        // --- ADD QUADRANT LABELS & AXIS MARKERS ---
        const fontLoader = new THREE.FontLoader();
        let scaleFactor = 5.0; 

        fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
            
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0x1e40af, transparent: true, opacity: 0.7 });
            const labelScale = scaleFactor * 6; 

            function createLabel(text, x, z) {
                const textGeo = new THREE.TextGeometry(text, {
                    font: font, size: 2.5, height: 0.1, curveSegments: 12,
                });
                textGeo.computeBoundingBox();
                const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
                const textMesh = new THREE.Mesh(textGeo, textMaterial);
                textMesh.rotation.x = -Math.PI / 2; 
                textMesh.position.set(x + centerOffset, 0.1, z); 
                scene.add(textMesh);
            }

             // Fungsi marker axis yang sudah diperbaiki
            function createAxisMarker(text, x, z, rotZ) {
                const textGeo = new THREE.TextGeometry(text, {
                    font: font, size: 2.2, height: 0.1, curveSegments: 12
                });
                textGeo.computeBoundingBox();
                const textMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial({ color: 0xff4444, opacity: 0.9, transparent: true })); 
                
                // PERBAIKAN ROTASI:
                // 1. Putar -90 derajat di X agar teks rebah/sejajar lantai
                textMesh.rotation.x = -Math.PI / 2;
                // 2. Gunakan rotZ untuk menentukan arah hadap teks di lantai
                textMesh.rotation.z = rotZ; 
                
                textMesh.position.set(x, 0.2, z); // Sedikit lebih tinggi dari lantai (0.2) agar tidak flickering
                scene.add(textMesh);
            }

            createLabel(labelData.tr, labelScale, -labelScale); 
            createLabel(labelData.tl, -labelScale, -labelScale); 
            createLabel(labelData.br, labelScale, labelScale);  
            createLabel(labelData.bl, -labelScale, labelScale); 

            createAxisMarker("X-AXIS", maxRadius * 1.3, 0, 0); 
            createAxisMarker("Y-AXIS", -5, -maxRadius * 1.3, 0);
        });

        // --- 4. DATA PROCESSING ---
        let rawData = [];
        let configData = { xLabel: "Probability", yLabel: "Impact" };
        let labelData = { tl: "BLACK SWANS", tr: "CRITICAL RISKS", bl: "ROUTINE", br: "TACTICAL" };

        try {
            const savedNodes = localStorage.getItem('horizon_3d_nodes');
            const savedConfig = localStorage.getItem('horizon_3d_config');
            const savedLabels = localStorage.getItem('horizon_3d_labels'); 
            
            if (savedNodes) rawData = JSON.parse(savedNodes);
            if (savedConfig) configData = JSON.parse(savedConfig);
            if (savedLabels) labelData = JSON.parse(savedLabels); 
            
            //const labelX = document.getElementById('legend-x-label');
            //const labelY = document.getElementById('legend-y-label');
            // Ganti baris ini di dalam event listener mousemove
            //const ttX = document.getElementById('lbl-tt-x');
            //const ttY = document.getElementById('lbl-tt-y');

           // if(ttX) ttX.innerText = (configData.xLabel || "Probability") + ":";
            //if(ttY) ttY.innerText = (configData.yLabel || "Impact") + ":";
            
        } catch (e) { console.error("Gagal memuat data:", e);}

        if (rawData.length === 0) {
             rawData = [{ id: "d1", title: "Contoh Data Radar Aktif", desc: "Data placeholder.", status: "critical", x: 7.5, y: 8.5, z: 6.5, connections: [] }];
        }

        const statusMap = {
            "critical":   { color: 0xdc2626 }, 
            "escalating": { color: 0xea580c }, 
            "structural": { color: 0x2563eb }, 
            "emerging":   { color: 0x059669 }, 
            "watchlist":  { color: 0xd97706 }  
        };

        const objectsArray = []; 
        const nodePositions = {}; 

        // --- 5. RENDER NODES ---
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32); 

        rawData.forEach((data, index) => {
            data.x = parseFloat(data.x) || 0;
            data.y = parseFloat(data.y) || 0;
            data.z = parseFloat(data.z) || 0; 
            if (!statusMap[data.status]) data.status = 'emerging'; 

            const material = new THREE.MeshStandardMaterial({ 
                color: statusMap[data.status].color, 
                roughness: 0.4, 
                metalness: 0.1, 
            });
            const sphere = new THREE.Mesh(sphereGeo, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;

            const posX = data.x * scaleFactor;
            const posZ = -data.y * scaleFactor;
            let altitude = 2.0 + (data.z * 4.0); 
            const posY = altitude;
            const baseScale = Math.max(0.8, (Math.abs(data.y) / 10) * 4.0);

            sphere.scale.set(baseScale, baseScale, baseScale);
            sphere.position.set(posX, posY, posZ);
            
            scene.add(sphere);
            objectsArray.push(sphere);
            nodePositions[data.id] = sphere.position;

            const stalkMat = new THREE.LineBasicMaterial({ color: 0x334155, transparent: true, opacity: 0.9 });
            const stalkGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(posX, 0, posZ),
                new THREE.Vector3(posX, posY, posZ)
            ]);
            scene.add(new THREE.Line(stalkGeo, stalkMat));
            
            const floorRingGeo = new THREE.RingGeometry(baseScale * 0.5, baseScale * 0.7, 32);
            // Hapus AdditiveBlending di sini juga
            const floorRingMat = new THREE.MeshBasicMaterial({ color: neonGreen, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            const floorRing = new THREE.Mesh(floorRingGeo, floorRingMat);
            floorRing.position.set(posX, 0.03, posZ);
            floorRing.rotation.x = -Math.PI / 2;
            scene.add(floorRing);

            sphere.userData = { ...data, color: statusMap[data.status].color, baseScale: baseScale, floorRing: floorRing };
        });

        // --- UI EVENTS ---
        let nodeSizeMultiplier = 1.0;
        document.getElementById('nodeSizeSlider').addEventListener('input', (e) => {
            nodeSizeMultiplier = parseFloat(e.target.value);
            document.getElementById('nodeSizeValue').innerText = Math.round(nodeSizeMultiplier * 100) + '%';
            objectsArray.forEach(sphere => {
                const newScale = sphere.userData.baseScale * nodeSizeMultiplier;
                sphere.scale.set(newScale, newScale, newScale);
                if (sphere.userData.floorRing) sphere.userData.floorRing.scale.set(nodeSizeMultiplier * 0.7, nodeSizeMultiplier * 0.9, 1);
            });
        });

        document.getElementById('autoRotateToggle').addEventListener('change', (e) => {
            controls.autoRotate = e.target.checked;
        });

        // --- 6. CONNECTIONS ---
        const curveMaterial = new THREE.LineDashedMaterial({ 
            color: 0x475569, 
            transparent: true, 
            opacity: 0.6, 
            dashSize: 0.8, 
            gapSize: 0.4,
        });
        
        rawData.forEach(data => {
            if (data.connections && data.connections.length > 0) {
                data.connections.forEach(targetId => {
                    const p1 = nodePositions[data.id];
                    const p2 = nodePositions[targetId];
                    if (p1 && p2) {
                        const distance = p1.distanceTo(p2);
                        const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                        midPoint.y = Math.max(p1.y, p2.y) + (distance * 0.15); 
                        const curve = new THREE.QuadraticBezierCurve3(p1, midPoint, p2);
                        const points = curve.getPoints(32);
                        const curveGeo = new THREE.BufferGeometry().setFromPoints(points);
                        const curvedLine = new THREE.Line(curveGeo, curveMaterial);
                        curvedLine.computeLineDistances();
                        scene.add(curvedLine);
                    }
                });
            }
        });

        // --- 7. MOUSE INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        let hoveredObj = null;
        let originalScale = new THREE.Vector3();
        let originalColor = new THREE.Color(); 

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objectsArray);

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                const object = intersects[0].object;
                
                if (hoveredObj !== object) {
                    if (hoveredObj) {
                         hoveredObj.scale.copy(originalScale);
                         hoveredObj.material.color.copy(originalColor); 
                    }
                    hoveredObj = object;
                    originalScale.copy(object.scale);
                    originalColor.copy(object.material.color); 
                    
                    object.scale.multiplyScalar(1.15);
                    object.material.color.lerp(new THREE.Color(0xffffff), 0.3);

                    const data = object.userData;
                    document.getElementById('tt-name').innerText = data.title;
                    document.getElementById('tt-desc').innerText = data.desc || "";
                    document.getElementById('tt-x').innerText = data.x.toFixed(1);
                    document.getElementById('tt-y').innerText = data.y.toFixed(1);
                    document.getElementById('tt-z').innerText = data.z.toFixed(1);
                    
                    const badge = document.getElementById('tt-badge');
                    badge.innerText = data.status;
                    badge.style.background = "#" + data.color.toString(16).padStart(6, '0');
                }
                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
            } else {
                document.body.style.cursor = 'default';
                if (hoveredObj) {
                    hoveredObj.scale.copy(originalScale);
                    hoveredObj.material.color.copy(originalColor);
                    hoveredObj = null;
                }
                tooltip.style.display = 'none';
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 8. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            if (window.sweepMat) {
                window.sweepMat.uniforms.uTime.value = time;
            }

            controls.update(); 
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
