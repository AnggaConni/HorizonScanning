<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Horizon Scanning Radar - Standalone Edition</title>
    <style>
        /* --- CSS FIX: Prevents radar from shifting downwards --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f8fafc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #1e293b;
        }

        #canvas-container {
            position: fixed; /* Locks position on screen */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1; 
            background: radial-gradient(circle at center, #ffffff 0%, #e2e8f0 100%); 
        }

        /* UI Layer stays above radar */
        #ui-layer {
            position: absolute;
            top: 25px;
            left: 25px;
            pointer-events: none;
            z-index: 10;
        }

        h1 { margin: 0; font-size: 24px; font-weight: 700; color: #0f172a; }
        p { margin: 4px 0 0 0; font-size: 13px; color: #64748b; }

        .legend {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(203, 213, 225, 0.5);
            backdrop-filter: blur(10px);
            width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            pointer-events: auto;
        }

        .legend-title { font-size: 11px; text-transform: uppercase; font-weight: 800; color: #10b981; margin-bottom: 10px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 12px; color: #334155; }
        .icon-box { width: 24px; margin-right: 10px; display: flex; justify-content: center; }

        #settings-panel {
            position: absolute;
            top: 25px;
            right: 25px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(203, 213, 225, 0.5);
            backdrop-filter: blur(10px);
            width: 220px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            z-index: 20;
        }

        #settings-title { font-size: 11px; font-weight: 800; text-transform: uppercase; margin-bottom: 15px; color: #10b981; border-bottom: 1px solid #f1f5f9; padding-bottom: 8px; }
        .settings-label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 10px; color: #334155; }

        #tooltip {
            position: absolute;
            display: none;
            background: white;
            border: 1px solid #e2e8f0;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            z-index: 100;
            width: 250px;
        }

        .tt-title { font-weight: 700; color: #0f172a; margin-bottom: 4px; }
        .tt-desc { font-size: 12px; color: #64748b; line-height: 1.4; margin-bottom: 8px; }
        .status-badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 800; color: white; text-transform: uppercase; }

        #exportBtn {
            width: 100%;
            margin-top: 15px;
            padding: 10px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            font-size: 11px;
            cursor: pointer;
            transition: 0.2s;
        }
        #exportBtn:hover { background: #059669; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Strategic Foresight Radar</h1>
        <p>3D Visualization of Future Signals</p>
        
        <div class="legend">
        <div class="legend-title">Radar Guide</div>
        <div class="legend-item"><div class="icon-box">ðŸ“Œ</div> <div><strong>Floor:</strong> X & Y Position</div></div>
        <div class="legend-item"><div class="icon-box">ðŸš€</div> <div><strong>Altitude:</strong> Urgency (Z-Axis)</div></div>
        <div class="legend-item"><div class="icon-box">ðŸŸ¢</div> <div><strong>Size:</strong> Signal Impact Magnitude</div></div>
    </div>
    </div>

    <div id="settings-panel">
        <div id="settings-title">Control Panel</div>
        <div class="settings-label">
            <label for="autoRotateToggle" style="cursor:pointer">Auto-Rotate</label>
            <input type="checkbox" id="autoRotateToggle" checked style="cursor:pointer">
        </div>
        <div class="settings-label">
            <span>Node Scale</span>
            <span id="nodeSizeValue">100%</span>
        </div>
        <input type="range" id="nodeSizeSlider" min="0.2" max="2.0" step="0.1" value="1.0" style="width:100%; accent-color:#10b981; cursor:pointer">
        
        <button id="exportBtn">DOWNLOAD STANDALONE (.HTML)</button>
    </div>

    <div id="tooltip">
        <div class="tt-title" id="tt-name">Signal</div>
        <div class="tt-desc" id="tt-desc">Description</div>
        <div id="tt-badge" class="status-badge">STATUS</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script>
        // --- 1. CONFIG & DATA ---
        let rawData = [{"id":"d1","title":"Main Signal","desc":"Welcome to your Strategic 3D Radar. Hover over nodes or connection lines to see details.","status":"emerging","x":5,"y":5,"z":5,"connections":[]}];
        let configData = {"xLabel":"Probability","yLabel":"Impact"};
        let labelData = {"tl":"BLACK SWANS","tr":"CRITICAL RISKS","bl":"ROUTINE","br":"TACTICAL"};

        const statusMap = {
            "critical":   { color: 0xdc2626 }, 
            "escalating": { color: 0xea580c }, 
            "structural": { color: 0x2563eb }, 
            "emerging":   { color: 0x059669 }, 
            "watchlist":  { color: 0xd97706 }  
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 70, 80);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5; // Tambahkan ini. Semakin kecil nilainya (misal 0.2), semakin lambat.

        const objectsArray = [];
        const connectionsArray = [];
        const scaleFactor = 5.0;

        // --- 2. RENDER ENGINE ---
        function initRadar() {
            // Cleanup Scene
            while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            objectsArray.length = 0;
            connectionsArray.length = 0;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(50, 80, 50);
            scene.add(dl);

            const neonGreen = 0x10b981;

            // Floor Grid Rings
            for (let i = 1; i <= 5; i++) {
                const radius = (55 / 5) * i;
                const ringGeo = new THREE.RingGeometry(radius - 0.1, radius + 0.1, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: neonGreen, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                scene.add(ring);
            }

            // X & Y Axis Lines
            const axisMat = new THREE.LineBasicMaterial({ color: neonGreen, transparent: true, opacity: 0.4 });
            const lineX = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-60, 0.01, 0), new THREE.Vector3(60, 0.01, 0)]);
            const lineY = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0.01, -60), new THREE.Vector3(0, 0.01, 60)]);
            scene.add(new THREE.Line(lineX, axisMat));
            scene.add(new THREE.Line(lineY, axisMat));

            // Radar Sweep Scanner
            const sweepGeo = new THREE.PlaneGeometry(110, 110);
            const sweepMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color(neonGreen) } },
                vertexShader: `
                    varying vec2 vUv; 
                    void main() { 
                        vUv = uv; 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv; 
                    uniform float uTime; 
                    uniform vec3 uColor; 
                    #define PI 3.14159265 
                    void main() { 
                        vec2 center = vec2(0.5, 0.5); 
                        vec2 toCenter = vUv - center; 
                        float dist = length(toCenter); 
                        if (dist > 0.49 || dist < 0.01) discard; 
                        float angle = atan(toCenter.y, toCenter.x); 
                        float normalizedAngle = (angle + PI) / (2.0 * PI); 
                        float rotation = mod(-uTime * 0.3, 1.0); 
                        float diff = rotation - normalizedAngle; 
                        if (diff < 0.0) diff += 1.0; 
                        float alpha = pow(1.0 - smoothstep(0.0, 0.35, diff), 3.0); 
                        gl_FragColor = vec4(uColor, alpha * 0.4); 
                    }
                `,
                transparent: true, depthWrite: false, side: THREE.DoubleSide
            });
            const sweepMesh = new THREE.Mesh(sweepGeo, sweepMat);
            sweepMesh.rotation.x = -Math.PI / 2;
            sweepMesh.position.y = 0.02;
            scene.add(sweepMesh);
            window.activeSweepMat = sweepMat;

            // Render Nodes
            const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
            const nodePositions = {};

            rawData.forEach(data => {
                const color = statusMap[data.status] ? statusMap[data.status].color : 0xcccccc;
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.3, 
                    metalness: 0.2,
                    emissive: new THREE.Color(0x000000) 
                });
                const sphere = new THREE.Mesh(sphereGeo, mat);
                
                const posX = (parseFloat(data.x) || 0) * scaleFactor;
                const posZ = -(parseFloat(data.y) || 0) * scaleFactor;
                const posY = 2 + ((parseFloat(data.z) || 0) * 4);
                const scale = Math.max(0.8, (Math.abs(data.y) / 10) * 3.5);

                sphere.position.set(posX, posY, posZ);
                sphere.scale.set(scale, scale, scale);
                sphere.userData = { ...data, color, baseScale: scale, isNode: true };
                
                scene.add(sphere);
                objectsArray.push(sphere);
                nodePositions[data.id] = sphere.position;

               // --- MULAI KODE STALK BARU ---
                // Menggunakan Cylinder (Tabung) agar ketebalan bisa diatur, karena WebGL membatasi ketebalan Line biasa.

                // 1. Atur Ketebalan di sini. Semakin besar angkanya, semakin tebal tiangnya (default sebelumnya setara 0.05).
                const stalkThickness = 0.2; 

                // 2. Buat bentuk tabung: (radiusAtas, radiusBawah, tinggi, jumlahSisi)
                // Tingginya mengambil dari variabel posY (tinggi bola dari lantai)
                const stalkGeo = new THREE.CylinderGeometry(stalkThickness, stalkThickness, posY, 8);

                // 3. Buat material/warna tiangnya
                const stalkMat = new THREE.MeshBasicMaterial({ 
                    color: 0x94a3b8,       // Warna abu-abu kebiruan
                    transparent: true,     // Mengaktifkan transparansi
                    opacity: 0.6           // Ketebalan warna (naikkan ke 0.8 atau 1.0 jika ingin lebih solid/tidak tembus pandang)
                });

                // 4. Gabungkan bentuk dan warna menjadi objek 3D
                const stalk = new THREE.Mesh(stalkGeo, stalkMat);

                // 5. Posisikan tiang. 
                // Karena titik tengah (origin) tabung ada di tengah-tengah badannya, 
                // maka posisi Y-nya harus ditaruh di pertengahan antara lantai (0) dan posisi bola (posY).
                stalk.position.set(posX, posY / 2, posZ);

                // 6. Masukkan ke dalam scene (layar)
                scene.add(stalk);
                // --- AKHIR KODE STALK BARU ---
            });

            // Quadratic Bezier Connections with Interactivity
            const curveMat = new THREE.LineDashedMaterial({ color: 0x94a3b8, dashSize: 0.5, gapSize: 0.3, transparent: true, opacity: 0.5 });
            rawData.forEach(data => {
                if (data.connections) {
                    data.connections.forEach(targetId => {
                        const p1 = nodePositions[data.id];
                        const p2 = nodePositions[targetId];
                        const targetData = rawData.find(d => d.id === targetId);
                        if (p1 && p2 && targetData) {
                            const mid = new THREE.Vector3((p1.x + p2.x)/2, Math.max(p1.y, p2.y) + 5, (p1.z + p2.z)/2);
                            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
                            const pts = curve.getPoints(32);
                            const geo = new THREE.BufferGeometry().setFromPoints(pts);
                            const line = new THREE.Line(geo, curveMat.clone());
                            line.computeLineDistances();
                            line.userData = { 
                                isConnection: true, 
                                sourceName: data.title, 
                                targetName: targetData.title,
                                originalColor: 0x94a3b8
                            };
                            scene.add(line);
                            connectionsArray.push(line);
                        }
                    });
                }
            });

        // Quadrant Labels
        const loader = new THREE.FontLoader();
        loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
        // Material biru untuk nama kuadran
        const labelMat = new THREE.MeshBasicMaterial({ color: 0x1e40af, transparent: true, opacity: 0.5 });
        
        // Material merah muda untuk tulisan Axis
        const axisMat = new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.8 });

        // Tambahkan parameter material dan size ke fungsi createLabel
        const createLabel = (text, x, z, material = labelMat, size = 2) => {
        const geo = new THREE.TextGeometry(text, { font, size: size, height: 0.1 });
        
        // Membaca bounding box agar posisi teks bisa center-aligned
        geo.computeBoundingBox();
        const xOffset = -0.5 * (geo.boundingBox.max.x - geo.boundingBox.min.x);
        
        const mesh = new THREE.Mesh(geo, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(x + xOffset, 0.1, z); // Ditambah xOffset agar teks posisinya pas di tengah garis
        scene.add(mesh);
    };

            // Render Label Kuadran (Biru, Ukuran Default)
            createLabel(labelData.tr, 25, -25);  // Kanan Atas (CRITICAL RISKS)
            createLabel(labelData.tl, -25, -25); // Kiri Atas (BLACK SWANS) -> Ubah dari -45 jadi -25
            createLabel(labelData.br, 25, 30);   // Kanan Bawah (TACTICAL) -> Saya sesuaikan jadi 30 agar jarak atas-bawah juga seimbang
            createLabel(labelData.bl, -25, 30);  // Kiri Bawah (ROUTINE) -> Ubah dari -45 jadi -25

            // Render Label Axis (Merah, Ukuran Lebih Besar = 3)
            // Posisinya diletakkan di ujung garis terluar (65 dan -65)
            createLabel("X-Axis", 66, 1, axisMat, 2); 
            createLabel("Y-Axis", 0, -62, axisMat, 2);
            
            // Opsional: Kalau mau pakai nama sumbu otomatis dari config (Probability/Impact), 
            // ganti "X-Axis" jadi configData.xLabel dan "Y-Axis" jadi configData.yLabel
            });
        }

        // --- 3. DATA LOADING ---
        function loadRadarData() {
            try {
                const saved = localStorage.getItem('horizon_3d_nodes');
                if (saved && rawData.length <= 1) {
                    rawData = JSON.parse(saved);
                    const sc = localStorage.getItem('horizon_3d_config');
                    const sl = localStorage.getItem('horizon_3d_labels');
                    if (sc) configData = JSON.parse(sc);
                    if (sl) labelData = JSON.parse(sl);
                    console.log("Loaded from Browser Storage.");
                } else {
                    console.log("Loaded Standalone Mode (Internal Data).");
                }
            } catch (e) { console.log("Standalone mode active."); }
            initRadar();
        }
        loadRadarData();

        // --- 4. EXPORT FUNCTION ---
        document.getElementById('exportBtn').addEventListener('click', () => {
            const clean = (obj) => JSON.stringify(obj).replace(/\\n/g, " ").replace(/\\r/g, " ");
            let html = document.documentElement.outerHTML;
            html = html.replace(/<canvas.*?>.*?<\/canvas>/g, "");
            
            html = html.replace(/let rawData\s*=\s*\[[\s\S]*?\];/, `let rawData = ${clean(rawData)};`);
            html = html.replace(/let configData\s*=\s*\{[\s\S]*?\};/, `let configData = ${clean(configData)};`);
            html = html.replace(/let labelData\s*=\s*\{[\s\S]*?\};/, `let labelData = ${clean(labelData)};`);

            const blob = new Blob([html], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `Strategic_Radar_Export_${new Date().getTime()}.html`;
            a.click();
        });

        // --- 5. UI & ANIMATION ---
        document.getElementById('autoRotateToggle').addEventListener('change', (e) => {
            controls.autoRotate = e.target.checked;
        });

        document.getElementById('nodeSizeSlider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('nodeSizeValue').innerText = Math.round(val * 100) + '%';
            objectsArray.forEach(s => { 
                s.scale.set(s.userData.baseScale * val, s.userData.baseScale * val, s.userData.baseScale * val); 
            });
        });

        // Interaction Logic with Glow and Tooltip Description
        let intersectedObj = null;
        const raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 0.5; // Increased threshold for easier line selection

        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const hitsNodes = raycaster.intersectObjects(objectsArray);
            const hitsLines = raycaster.intersectObjects(connectionsArray);
            const tt = document.getElementById('tooltip');
            
            // Reset previous hover state
            if (intersectedObj) {
                if (intersectedObj.userData.isNode) {
                    intersectedObj.material.emissive.setHex(0x000000);
                } else if (intersectedObj.userData.isConnection) {
                    intersectedObj.material.color.setHex(intersectedObj.userData.originalColor);
                    intersectedObj.material.opacity = 0.5;
                }
                intersectedObj = null;
            }

            if (hitsNodes.length > 0) {
                const obj = hitsNodes[0].object;
                const d = obj.userData;
                intersectedObj = obj;
                obj.material.emissive.setHex(0x333333); // Glow node

                document.getElementById('tt-name').innerText = d.title;
                document.getElementById('tt-desc').innerText = d.desc || "No description provided.";
                const badge = document.getElementById('tt-badge');
                badge.innerText = d.status.toUpperCase();
                badge.style.background = "#" + d.color.toString(16).padStart(6, '0');
                badge.style.display = "inline-block";
                
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY + 15) + 'px';
                document.body.style.cursor = 'pointer';

            } else if (hitsLines.length > 0) {
                const line = hitsLines[0].object;
                const d = line.userData;
                intersectedObj = line;
                line.material.color.setHex(0x10b981); // Glow line (Neon Green)
                line.material.opacity = 1.0;

                document.getElementById('tt-name').innerText = "Connection Link";
                document.getElementById('tt-desc').innerHTML = `Connects:<br><strong>${d.sourceName}</strong> &rarr; <strong>${d.targetName}</strong>`;
                const badge = document.getElementById('tt-badge');
                badge.style.display = "none";
                
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY + 15) + 'px';
                document.body.style.cursor = 'pointer';

            } else {
                tt.style.display = 'none';
                document.body.style.cursor = 'default';
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if(window.activeSweepMat) window.activeSweepMat.uniforms.uTime.value = clock.getElapsedTime();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
